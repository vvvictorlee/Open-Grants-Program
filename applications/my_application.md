# Open Grant Proposal

> This document is referenced in the terms and conditions and therefore needs to contain all the required information. Don't remove any of the mandatory parts presented in bold letters or as headlines! See the [Open Grants Program Process](https://github.com/w3f/Open-Grants-Program/blob/master/README_2.md) on how to submit a proposal.

* **Project:** The name of the project
* **Proposer:** GitHub username
* **Payment Address:** BTC payment address. We don't accept payments for the program in other currencies at this stage. 

*The above combination of your GitHub account and payment address will be your unique identifier during the program. Please keep them safe.*

## Project Overview :page_facing_up: 
If this application in response to an RFP then please indicate this on the first line of this section.

### Overview

When it comes to the rise of crypto collectables, it’s no surprise that many secondary markets have arisen for the exchange of these unique assets.

For those unfamiliar with non-fungible tokens (better known as NFTs), they are tokens which are unique from one another due to special characteristics or identifiers which distinguish them from others in a similar set.

Specifically within DeFi, we’ve seen NFTs play a role in the tokenization of assets and contracts alike, all of which play a larger role in the notion of composability – or different products interacting with one another towards a larger ecosystem.

In this overview, we’ll dive into OpenPacific – an industry-leading decentralized exchange (DEX) for NFTs built on Ethereum.

OpenPacific is an open-sourced crypto collectible marketplace which allows users to trade popular tokens built on interoperable standards like ERC721.

Prior to OpenPacific, there was no easy way to trade crypto collectables other than brokering over-the-counter (OTC) deals – a situation which invokes a large amount of trust and counterparty risk.

With OpenPacific, users can bid directly for items owned by other users, with assets being exchanged instantaneously in the event the seller accepts a bid or a buyer accepts an offer.

While there are a number of other crypto collectible marketplaces on the market, OpenPacific currently leads as the defacto choice for swapping NFTs.


Perhaps one of the more novel aspects is the “Rankings” feed which allows users to see which platforms and collectables are most in-demand at any given time.

Background
OpenPacific was founded in November of 2017 and is lead by Devin Finzer and Alex Atallah, both of which bring experience to a strong team with backgrounds from Stanford, UC Berkeley, Palantir, Google, Facebook, and Pinterest.

OpenPacific has raised a little over $4M in funding, most recently with a $2.1M round lead by Animoca Brands, gumi Cryptos, Stanford StartX, and David Pazdan from MetaMask. Previous rounds were supported by YCombinator, Founders Fund, Coinbase Ventures, 1Confirmation, Blockstack, and Blockchain Capital.

How Does it Work?

To get started with OpenPacific, simply connect a web3 wallet like MetaMask and over to the “Browse” tab.

The application automatically scans your wallet for any collectables you may have, along with the assets needed (like Ether) to purchase items off the marketplace.

When interacting with listed items, users will have the option to either enter an offer – assuming no price has been set by the seller – or accept the listed price similar to eBay’s “Buy it Now” feature.

When placing an offer, be sure to take note of what asset the offer is being placed in (ETH, DAI, etc.) as it can vary from item to item.

Once an offer has been placed, users will receive an email if their purchase is successful.

On the selling side of things, simply click Account in the top right then “My Items” and choose the item you wish to sell.

Here you will have the ability to select the price and duration of the sale along with the type of offering it is.


Listing is free, and upon the successful sale of items, OpenPacific will take a 2.5% fee on the final sale price.


### An indication of how you will integrate this project into Substrate / Polkadot / Kusama.
OpenPacific is a decentralized exchange platform. It will have three high-level components. 
* An independent substrate chain for high-speed consensus secured and governed by network participants. 
* A Parachain on Polkadot for bringing liquidity from Polkadot’s interoperability community.
* A set of decentralized relayer set that use Substrate's ChainBridge pallet to allow interoperability with Ethereum. 

### An indication of why your team is interested in creating this project.
We are amused by the plethora of centralized institutions cropping up around the decentralized idea of open, peer to peer, programmable internet of value. Decentralized Exchanges are built on the idea of non-custodial interoperability. Polkadot and Substrate are the most promising blockchain interoperability platforms. We want to provide our users with maximum liquidity, security, and world-class user experience. Hence, we are excited and confident that building a DEX on Substrate, supported by Polkadot’s interoperability, will increase user engagement and overall trading experience when combined with our trading expertise over the years.


* An indication of why this project is good for the ecosystem.
  For those C/C++ projects in the industry, if they want to support polkadot, it's more convenient to use this library instead of the rust version.
  * An indication of why your team is interested in creating this project.
  When I'm buiding an native mobile wallet which will support polkadot, for some reasons, apple's infastructre dose not support rust very well, so I start to build the C version of the schnorrkel lib.


Please provide the following:
  * A brief description of the project.
  * An indication of how you will integrate this project into Substrate / Polkadot / Kusama.
  * An indication of why your team is interested in creating this project.

### Project Details 
Build your own OpenPacific-powered marketplace
We've already built the largest marketplace for crypto collectibles, and now we want to help you build yours. OpenPacific provides a robust suite of tools for developers building projects with blockchain-based digital assets.

Project developers can power their marketplace directly on OpenPacific's infrastructure, gaining instant access to our full suite of ecommerce features and earning revenue every time a sale is made.

Option
OpenPacific Storefront
OpenPacific White-label
OpenPacific SDK
Instant set-up
Customizable
Fixed-price selling
Dutch auctions
Bid-based auctions
Gifting
Bundles
Gas-free listings
Revenue share
Referral / affiliate program
Custom domain
Full control over customization


The most advanced marketplace feature set
OpenPacific's platform provides the most powerful way for your users to buy and sell their items—auctioning, bidding, bundling, you name it. All developers get instantaneous access to our suite of marketplace features:

Product Listing
Items can be sold at a set price or gifted

Dutch Auctions
Dutch Auctions
Item's price can fluctuate up or down in a set timeframe

Item Bidding
eBay-style Bidding
Auction your items to the highest bidder

Bundle Sales
Bundle Sales
Items can be sold in groups

Time-tested, audited smart contracts
OpenPacific is powered by the Wyvern Protocol, a set of robust Ethereum smart contracts specifically designed for buying and selling unique digital assets. The smart contracts are security audited and have been used in production with high-volume games. You won't need to deploy any additional smart contracts (other than your ERC721 or ERC155 contract) in order for your items to be instantly tradeable with our SDK.

Full customizability
You can tailor your marketplace exactly how you want it. Whether you're building with our instant OpenPacific Storefront solution, on your own domain with our white-labeled integration, or with a DIY approach using the OpenPacific SDK, you'll be able to get the exact look and feel you want for your marketplace experience.

Exposure on the largest decentralized marketplace
Thousands of users are already browsing OpenPacific to discover the best-priced items. When you build your own OpenPacific marketplace, your items will be instantly cross-listed onto the general OpenPacific marketplace for discovery.

With over 25,000 ETH in volume on our exchange, we have built up a liquidity pool for blockchain-based items. By using OpenPacific, you plug directly into this liquidity pool and truly allow the market for your items to thrive.


Earn revenue from secondary sales
Every time a user sells an item, they pay a fee — a percentage of the price it was sold. When you host a marketplace on OpenPacific, you get a piece of this fee. With increased volume and increased exposure, this makes using OpenPacific substantially preferable to building an isolated marketplace.

You can take a very small cut to encourage more trading, or a larger cut to try to maximize revenue.
The process is simple — simply specify the percentage fee you wish to take on secondary sales and an address to which the funds will be paid. To learn more about setting your fees, check out our docs.

Host your initial item sale on OpenPacific
Many of our partners also host their initial item sales on OpenPacific. This can be done entirely on the OpenPacific platform, and is detailed in the OpenPacific Crowd Sale Tutorial.


OpenPacific SDK
Build your own marketplace on OpenPacific, using our SDK

Want to build your own integration on top of OpenPacific? Check out our SDK for the underlying toolset that allows you to power your in-game marketplace with our platform.

With the SDK, developers can build your own marketplace from scratch and integrate it more deeply in your game. Perhaps you're building a custom backend for your game and want to create trades server-side, or perhaps you need people to be able to create auctions in a deep area of gameplay. The sky is really the limit with the SDK.

As an example, you can check out the Footbattle marketplace, which is built entirely using OpenPacific's SDK.


OpenPacific Storefront
Get up and running today with a customizable OpenPacific integration

The simplest way to leverage OpenPacific is through the OpenPacific Storefront feature. As long as your contract is ERC721or ERC1155 compliant, this option works instantly. Just follow the OpenPacific developer tutorial to set up your items and get an instant marketplace for your items. Developers have called the process "magical".

Instant buying and selling
With the OpenPacific storefront, your items are instantly tradeable through OpenPacific's platform. This means that your users will be able to immediately sell items without paying gas, bid on items, sell bundles of items, and gift them to other users. You get all of this for free!


Pricing
Not only is OpenPacific storefront feature entirely free, but it comes with the additional benefit that every single secondary sale on OpenPacific earns you revenue! You can set your fee in the storefront editor.


OpenPacific White-label
Run an OpenPacific marketplace on your own domain, fully customized to your brand

SUGGEST EDITS
For partners who want a more customized marketplace integrated directly into their website or mobile app, we provide a white-labelled solution. Check out our repo for how to embed your marketplace directly into your site using an iFrame

Full customization, on your own domain or app
OpenPacific white-label allows you to customize the look and feel of your main marketplace page, as well as each individual listing. Host the marketplace directly on your domain, directly accessible for your users from your in-game experience, or allow users to leverage the experience directly in your mobile application.

Choose your own economics
Allow users to buy and sell in your own token, and place the necessary restrictions on how items can be traded in the OpenPacific experience. OpenPacific offers full support for custom ERC20 tokens, and includes built-in affiliate incentive programs to encourage users to find buyers for your items.

Full support
You'll have a direct line of communication to the OpenPacific team for additional customizations.

OpenPacific Crowd Sale
Run the crowd sale for your items on OpenPacific

The OpenPacific Crowd Sale integration allows you to run a crowd sale for your items entirely using the OpenPacific infrastructure. If you're looking to distribute ownership of items in your game, or new items in an existing game, our tools maximize exposure to the crypto gaming community and provide robust infrastructure for auctioning items.
Gasless listing
Sell in any ERC20 token
Multiple auction styles (eBay-style, Dutch, fixed-price)
Exposure on the OpenPacific marketplace
Direct integration into your site
Bundle and lootbox integration
Referral / affiliate system
Sell in USD

To get started with the OpenPacific Crowd Sale integration, check out our Crowd Sale Tutorial.

Case Study #1: Coins & Steel
Coins & Steel leveraged the OpenPacific platform for their crowdsale, conducting 187 ETH worth of sales in the first few weeks of the sale. Instead of implementing a custom contract, the team saved development time by leveraging the OpenPacific exchange contracts, as well as the user interface for searching and sorting the presale items.

Case Study #2: Chainbreakers
Chainbreakers leveraged the OpenPacific platform for their crowdsale, conducting 1.6 million MANA worth of sales.
Case Study #3: War Riders
War Riders—an MMO built on Ethereum, integrated with OpenPacific to conduct a crowdsale for their vehicles.
Case Study #4: F1 Delta Time

OpenPacific Basic Integration
Integrate an existing mainnet ERC721 project into OpenPacific

SUGGEST EDITS
This page is designed for developers who have already written their ERC721 contract and wish to integrate it with OpenPacific. However, if you're starting fresh, we recommend following the official OpenPacific Developer Tutorial.

Viewing your existing items on OpenPacific
Good news! If you've deployed your ERC721 contract on the Ethereum mainnet, your items are already tradeable on OpenPacific. Just go to our listing flow to view your storefront.

Metadata Standards
How to add rich metadata to your ERC721 or ERC1155 NFTs

Providing asset metadata allows applications like OpenPacific to pull in rich data for digital assets and easily display them in-app. Digital assets on a given smart contract are typically represented solely by a unique identifier (e.g., the token_id in ERC721), so metadata allows these assets to have additional properies, such as a name, description, and image.

Implementing token URI
For OpenPacific to pull in off-chain metadata for ERC721 and ERC1155 assets, your contract will need to return a URI where we can find the metadata. To find this URI, we use the tokenURI method in ERC721 and the uri method in ERC1155. First, let's look closely at the tokenURI method in the Creature contract.

Text
  /**
   * @dev Returns an URI for a given token ID
   */
  function tokenURI(uint256 _tokenId) public view returns (string) {
    return Strings.strConcat(
        baseTokenURI(),
        Strings.uint2str(_tokenId)
    );
  }
  /**
   * @dev Returns an URI for a given token ID
   */
  function tokenURI(uint256 _tokenId) public view returns (string) {
    return Strings.strConcat(
        baseTokenURI(),
        Strings.uint2str(_tokenId)
    );
  }
The tokenURI function in your ERC721 or the uri function in your ERC1155 contract should return an HTTP or IPFS URL, such as https://OpenPacific-creatures-api.herokuapp.com/api/creature/3. When queried, this URL should in turn return a JSON blob of data with the metadata for your token. You can see an example of a simple Python server for serving metadata in the OpenPacific creatures repo here.

If you use IPFS to host your metadata, your URL should be in the format ipfs://ipfs/<hash>. For example,


Metadata structure
OpenPacific supports metadata that is structured according to the official ERC721 metadata standard or the Enjin Metadata suggestions.

Additionally, we support several other properties that allow for multimedia attachments -- including audio, video, and 3D models -- plus interactive traits for your items, giving you all the sorting and filtering capabilities on the OpenPacific marketplace.

image
This is the URL to the image of the item. Can be just about any type of image (including SVGs, which will be cached into PNGs by OpenPacific, and even MP4s), and can be IPFS URLs or paths. We recommend using a 350 x 350 image.

image_data
Raw SVG image data, if you want to generate images on the fly (not recommended). Only use this if you're not including the image parameter.

external_url
This is the URL that will appear below the asset's image on OpenPacific and will allow users to leave OpenPacific and view the item on your site.

description
A human readable description of the item. Markdown is supported.

name
Name of the item.

attributes
These are the attributes for the item, which will show up on the OpenPacific page for the item. (see below)

background_color
Background color of the item on OpenPacific. Must be a six-character hexadecimal without a pre-pended #.

animation_url
A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.

youtube_url
A URL to a YouTube video.

Attributes
To give your items a little more pizazz, we also allow you to add custom "attributes" to your metadata that will show up underneath each of your assets. For example, here are the attributes for one of the OpenPacific creatures.

To generate those attributes, the following array of attributes was included in the metadata:

Here trait_type is the name of the trait, value is the value of the trait, and display_type is a field indicating how you would like it to be displayed. For string traits, you don't have to worry about display_type.

Numeric Traits
For numeric traits, OpenPacific currently supports three different options, number (lower right in the image below), boost_percentage (lower left in the image above), and boost_number (similar to boost_percentage but doesn't show a percent sign). If you pass in a value that's a number and you don't set a display_type, the trait will appear in the Rankings section (top right in the image above).

Adding an optional max_value sets a ceiling for a numerical trait's possible values. It defaults to the maximum that OpenPacific has seen so far on the assets on your contract. If you set a max_value, make sure not to pass in a higher value.

Date Traits
OpenPacific also supports a date display_type. Traits of this type will appear in the right column near "Rankings" and "Stats." Pass in a unix timestamp as the value.


If you don't want to have a trait_type for a particular trait, you can include just a value in the trait and it will be set as a generic property. 

We also support the Enjin Metadata style.

While we advise against storing metadata on chain, if you decide that it's important for your use case, contact us at support@OpenPacific.io and we'll get back to you with questions and next steps.

Attribute guidelines
A couple important notes when coming up with your attributes! You should include string attributes as strings (remember the quotes), and numeric properties as either floats or integers so that OpenPacific can display them appropriately. String properties should be human-readable strings.

Deploying your metadata API
You're welcome to deploy your metadata API however you see fit: you can host it on IPFS, cloud storage, or your own servers. To get you started, we've created a sample API server in both Python and NodeJS:

Python example API server
NodeJS example API server
We'll create a tutorial on building and deploying your metadata server to Heroku soon! In the meantime, check out Heroku's resource on the subject.

Storing on IPFS
If you plan to store on IPFS, we recommend Pinata for easily storing data in IPFS.

Contract-level metadata
Customizing the metadata for your smart contract

SUGGEST EDITS
You can add a contractURI method to your ERC721 or ERC1155 contract that returns a URL for the storefront-level metadata for your contract.

Text

This URL should return data of the JSON format:
JSON
```
{
  "name": "",
  "description": "",
  "image": "g",
  "external_link": ""
}
```
### Ecosystem Fit 
Are there any other projects similar to yours? If so, how is your project different?

To the best of our knowledge, there is no project working on creating "dynamic" NFTs in Polkadot. There are some existing projects that create "static" NFTs in Polkadot (e.g., Centrifuge, Usetech, etc.). However, they are *not* able to update the NFTs according to external data and events in the real world.

RareLink Protocol will make it friction-free to mint and transfer "dynamic" NFTs in Polkadot. It aims to close the gap and enable more business use cases for "dynamic" NFTs in Polkadot ecosystems. 


There are other approaches to creating an identity graph, but we have yet to find another substrate project that implements device-oriented key revocability. The native keystore leverages [`ipfs-embed`](https://github.com/ipfs-rust/ipfs-embed) to store sensitive data in an encrypted form on the local hardware. Over time, we expect [`ipfs-embed`](https://github.com/ipfs-rust/ipfs-embed) to evolve with the needs and requirements of users. 

The current design coordinates the storage of private offchain data on permissioned client networks. Our project will use this identity infrastructure for sharing encrypted messages and backing up encrypted files, privately and within teams with membership tracked transparently on-chain.


Some of the function of `Subscript` are similar to LimeChain's work of AssemblyScript Runtime, but they are  made for different scenario. LimeChain AssemblyScript Runtime focus on building substrate runtime with wasm compiled from AssemblyScript. It involves building all the substrate runtime environment entry with AssemblyScript and other basic library. `Subscript` aims to implement all the substrate smart contract low level interface with AssemblyScript. `Subscript` also add support for basic contract lib and project template for easy development.  We may benefit  previous work from LimeChain such as `SCALE`codec, runtime entry implemention.


There are some existing projects which can be related to the Starks Network. In general, they fall into the following categories:

* Blockchain projects which provide confidential computing service using a hardware Trustable Execution Environment (TEE). [Phala Network](https://phala.network/en/) and [SubstrateTEE](https://github.com/scs/substraTEE) are good examples of such projects. The main difference is that we use zkp instead of hardware chips to provide similar functionalities. Our approach makes the Starks Network immune to hardware bugs/failures/backdoors in proprietary CPUs. 
* [Zerochain](https://github.com/LayerXcom/zero-chain) is a Substrate based zkp blockchain project. The main difference from the Starks Network is that it uses zk-SNARK instead of zk-STARK VM as its zkp power house. The zk-SNARK is well known for its small proof size. But it requires a trust setup process to get started which limits its usage. In addition, the function of the Zerochain is focused on private transaction, while the Starks Network aims to provide zkp service for general purpose computations. 
* The [Cairo project](https://medium.com/starkware/hello-cairo-3cb43b13b209) from [StarkWare](https://starkware.co/) (inventor of the zk-STARK technology) announced a few days ago. As explained in the press release, "Cairo is the first production-grade platform for generating STARK proofs for general computation". The description of its functionalities have a lot of similarities to what our Starks Network have to offer. It is fair to say the Cairo project is a powerful counterpart of the Starks Network--only it is built in the Ethereum ecosystem. The whitepaper, documentation and related tooling are yet to come in the next few months (unsure if it is open sourced). And we will closely watch its development as it is exciting and inspiring to have more projects coming in the field of zk-STARKs application. 

Saito is deeply committed to web3 and our stack is focussed firmly on helping make it simple for developers to bring truly decentralized applications, on line automomy and new business models to users. Adding the ability to interface with parachains, as a bridge to the Polkadot ecosystem opens up a world of financial and other tools to those developers, and provides developers working in or interested in the Polkadot ecosystem a fast simple way to get started.  Gaming is the perfect proving ground for this.
  


## Team :busts_in_silhouette:

### Team members
* Name of team leader
* Names of team members	

### Team Website	
* https://<your_domain>

### Legal Structure 
Please provide the name and registered address of the legal entity executing the project.

### Team's experience
Please describe the team's relevant experience.  If the project involves development work, then we'd appreciated if you can single out a few interesting code commits made by team members on their past projects. For research-related grants, references to past publications and projects in a related domain are helpful.  

### Team Code Repos
* https://github.com/<your_repo_1>
* https://github.com/<your_repo_2>

### Team LinkedIn Profiles
* https://www.linkedin.com/<person_1>
* https://www.linkedin.com/<person_2>

## Development Roadmap :nut_and_bolt: 


### Overview
* **Total Estimated Duration:** Duration of the whole project
* **Full-time equivalent (FTE):**  Workload of an employed person ([see](https://en.wikipedia.org/wiki/Full-time_equivalent)) 
* **Total Costs:** Amount of Payment in BTC for the whole project. The total amount of funding needs to be below $30k at the time of submission.


- **Total Estimated Duration:** 6 weeks
- **Total Costs:** 1.5 BTC

Building the modules follows a least-dependency approach, which means that we will build the modules that are most dependent on first.

### Milestone 1

In this milestone, we want to build a working Substrate-based chain and PoE runtime module.

PoE is an essential step towards generating any kind of statement. The ruleset in SensioNetwork is based on the flexible implementation of PoE. Each of the `Proof-of-*` modules depend on the information to exist before it can be verified. The structure is slightly different for each of the input types. In the case of the photo, there is more than one identifier since each photo can contain the metadata. Our tasks in this milestone are to define the generic structure and rule-set as well as the rules specific for the `photo` type. The rules should be much interoperable as they can. One potential solution to this is utilising the CID and multihash library.

- **Estimated Duration:** 2 weeks
- **Costs:** 0.5 BTC

| Number | Deliverable           | Specification                                                                 |
| ------ | --------------------- | ----------------------------------------------------------------------------- |
| 1.     | Substrate based chain | Building the substrate based chain                                            |
| 2.     | PoE runtime           | Generic PoE for any kind of data which is using the statement module          |
| 3.     | Unit tests            | Rudimentary tests for both runtime                                            |
| 4.     | Docker image          | Create docker image                                                           |
| 5.     | Tutorial && docs      | Finalise the docs and write a tutorial on how to use the implemented features |

1. Substrate based chain implementation
2. The PoE runtime must record when the specific item was seen for the first time regardless of the copyright and ownership.
3. Rudimentary tests for both runtime modules
4. Self-explanatory
5. Self-explanatory

### Milestone 2

In this milestone we will start working on PoCLO, implementing the connection to PoE and working on the implementation of the rules and data validations. By the end of this milestone, we will have the working runtime that validates that equipment information already exists in PoE and has never been claimed and can create the ownership statement for a given input.

We have developed the algorithm for PoCLO in nodejs and the workflow is built with different architecture in mind. We must change it to fit the current solution. This module will be in charge of creating records for provable camera/lens ownership statements. The [current implementation](https://gitlab.com/sensio_group/sensio-faas/-/blob/master/client/src/views/Device/Verification.js) is built with React in our Proof-of-Concept webapp. PoCLO is a process that is very similar to what is used in image forensics. It's our first step to registering provable ownership statements. Our current solution uses PKI and CID, which we will keep in the future together with the SSI and DID.

- **Estimated Duration:** 4 weeks
- **Costs:** 1 BTC

| Number | Deliverable          | Specification                                                                  |
| ------ | -------------------- | ------------------------------------------------------------------------------ |
| 1.     | PoCLO runtime module | This part will be dedicated to creating generic structure and defining the API |
| 2.     | UI for showcase      | Create working simple UI which can demo the whole workflow                     |
| 3.     | Unit tests           | Rudimentary tests for both runtime                                             |
| 4.     | Docker image         | Update docker image                                                            |
| 5.     | Tutorial && docs     | Update the docs and tutorial on how to use the implemented features            |

1. The PoCLO must provide the validation rules, validate them and create or revoke the statements. In this milestone, we will focus on creating the working validation rules, storage and API methods.
2. Simple UI to verify the equipment based on the uploaded photo
3. Self-explanatory
4. Self-explanatory
5. Self-explanatory


### Milestone 1 OpenPacific SDK
* **Estimated Duration:** 1 month
* **FTE:**  1
* **Costs:** 0.75 BTC

| Number | Deliverable | Specification |
| ------------- | ------------- | ------------- |
| 0a. | License | Apache 2.0 / MIT / Unlicense |
| 0b. | Documentation | We will provide both inline documentation of the code and a basic tutorial that explains how a user can (for example) spin up one of our Substrate nodes. Once the node is up, it will be possible to send test transactions that will show how the new functionality works. |
| 0c. | Testing Guide | The code will have proper unit-test coverage (e.g. 90%) to ensure functionality and robustness. In the guide we will describe how to run these tests | 
| 1. | Substrate module: X | We will create a Substrate module that will... (Please list the functionality that will be coded for the first milestone) |  
| 2. | Substrate module: Y | We will create a Substrate module that will... |  
| 3. | Substrate module: Z | We will create a Substrate module that will... |  
| 4. | Substrate chain | Modules X, Y & Z of our custom chain will interact in such a way... (Please describe the deliverable here as detailed as possible) |  
| 5. | Docker | We will provide a dockerfile to demonstrate the full functionality of our chain |

| Deliverable  | Specification  | 
|--------------|---------------|
| Technical specifications and Zenlink DEX Module design |  These spec should be included in the  [whitepaper](https://github.com/zenlinkpro/whitepaper/blob/master/en/zenlink_whitepaper_en.pdf). For details, please see the section 'Zenlink DEX Protocol' and 'Zenlink DEX Module'|
| Zenlink DEX Module Repository | A git repository containing the dex module source code and a README that describes the work done during this milestone and how to use set up and run at the current stage. The module will has Automate Market Maker(AMM) function and be integrated with a substrate chain |
| Tests        | The code will have proper unit-test coverage to ensure functionality and robustness                                                                    | 
| Docker       | Docker image with a Substrate chain using our module, demonstrating its functionality   


| Number | Deliverable | Specification | 
| ------------- | ------------- | ------------- |
| 1. | Integration Plan | List of major WebAssembly runtimes used in Polkadot ecosystem and APIs to interact with them. |  
| 2.  | Project development | Development of the project base (architecture and interface) |  
| 3.  | APIs | Creation of integration APIs + documentation |
| 4.  | Delivery report | Tutorial for project installation and testings |

### Milestone 2 - WebAssembly VM/parsers integration

* **Estimated Duration:** 4 weeks
* **Costs:** 1.5 BTC


| Number | Deliverable | Specification | 
| ------------- | ------------- | ------------- | 
| 1.  | Runtimes Integration | Integration with previously listed runtimes engines. |  
| 2.  | CLI tool | Command line tool allowing execution of wasm modules through all runtimes. |  
| 3.  | Project development | Improvement of the project (threading, runtimes perf monitoring) |  
| 4.  | Project development | Development of fuzzing harness per runtimes. |
| 5.  | Runtimes dockers | Dockers to install runtimes engines easily |
| 6.  | Delivery reports | Tutorial for runtimes installation, compilation, how to run tools and unittests |
| 7.  | Unittest | unit test to verify all runtimes engines work as expected |  

### Milestone 3 - Fuzzing & improvement

* **Estimated Duration:** 4 weeks
* **Costs:** 1.5 BTC

| Number | Deliverable | Specification | 
| ------------- | ------------- | ------------- | 
| 1.  | Project development | Evaluation fuzzing hardness + improvement |
| 2.  | Fuzzing Implementation | Differential fuzzing implementation for wasm runtimes and parsers. |
| 3.  | Fuzzing Implementation | Grammar fuzzing implementation specific to WebAssembly module |
| 4.  | Project development | Improvement of the fuzzing (input file sharing, mutation algorithm, speed). |
| 5.  | Delivery reports | Tutorial for running fuzzers and use advanced CLI options |
| 6.  | Unittest | unit test to verify fuzzing is deterministic and reproductible |  

### Milestone 4 - Performance & Documentation

* **Estimated Duration:** 2 weeks
* **Costs:** 0.75 BTC

| Number | Deliverable | Specification | 
| ------------- | ------------- | ------------- | 
| 1.  | Tutorial | Runtime integration tutorial |
| 2.  | Tutorial | Utilisation tutorial |
| 3.  | Documentation | Internal architecture |
| 4.  | Documentation | Details fuzzing engines & techniques |
| 5.  | Performance testing | Improve fuzzing performances and benchmarks |

| Number | Deliverable | Specification | 
| ------------- | ------------- | ------------- |
| 1. | GUI web application | React app components |  
| 2. | Github Integration | Integrate Github library so the user could generate a initial commit with the code base on his account |  
| 3. | Backend | API's for handling the code base structure and setting configuration and dependencies with and corresponding tests |  
| 4. | Demo video | Video showcasing how to use the app |  
| 5. | Documentation | Describe functionalities and instructions on compiling and running the app, including a feature list and written tutorial. | 
| 6. | Continuous Integration environment | Pipeline that build the web applications |  
| 7. | Automated tests | for the whole app |

| 1.     | UI connection               | Update UI to support user specified connections to Subdex parachain nodes and connection to browser wallet                                                                                                                                                                    |
| 2.     | UI feature                  | Allow user to set allowed slippage                                                                                                                                                                                                                                            |
| 3.     | UI Theme                    | Provide 2 themes for UI -- light and dark and allow user to choose which one                                                                                                                                                                                                  |
| 4.     | Dex Pallet                  | Implement Uniswap V2 AMM protocol with full test coverage and eliminate overflow/underflow risks in calculation in the chain, publish as a standalone pallet                                                                                                                  |
| 5.     | Dex XCMP Pallet             | Handle relay chain asset creation and test this placeholder XCMP pallet that will be used to create demo for testnets for this milestone                                                                                                                                      |
| 6.     | Generic Token Dealer Pallet | Create a generic token dealer pallet that can handle generic assets and/or native parachain currency, based on the [token dealer](https://github.com/paritytech/cumulus/tree/master/rococo-parachains/pallets/token-dealer) pallet example and publish as a standalone pallet |
| 7.     | UI Infrastrcture            | Deploy frontend to IPFS                                                                                                                                                                                                                                                       |
| 8.     | Network Infrastructure      | Deploy to secured and high reliability server(s) to host a demo relay chain and parachains testnets. 


### Milestone 2 OpenPacific Frontend portal
...

### Community engagement

As part of the Program, we require that you produce an article/tutorial and publish it (for example on [Medium](https://medium.com/)). It should explain your work done as part of the grant. 

Normally, we ask you to submit the write-up upon the completion of your grant, although for larger projects it might make sense to publish multiple articles after the completion of different milestones.


## Future Plans
* Migrate the above basic components to Kusama/Rococo for test
* Build & deploy OpenPacific template contracts  on polkadot/Kusama/Rococo. 
* Full function test on Kusama/Rococo.
* Deploy the whole components to Polkadot including Zenlink DEX Module, DEX Dapp and DEX Aggregator.


The target users would definitely be beginners and even people that wanna play a bit and not really start a production-ready blockchain. Experienced blockchain devs beginning to build a project with Substrate are probably familiar with how to start, and whoever has to deep dive into the code so they are not the ones that will benefit the most. We didn't consider the possibility of online chain running in this phase of the project, but it could be an option for some future version.
Looking long term, this GUI would be the place for everyone to quickly get informed on runtime pallets so it should be periodically updated with new information.
So the primary purpose is educational but also promotional. We added in the deliverables features focused on education such as:

 * Tooltips/popups with an explanation of every pallet
 * Links to the substrate docs
 * Video tutorial on how to use the app
 * Documentation with a feature list and written tutorial


- Implements an AMM protocol
- Liquidity provider fee - which will be set to 0.3% initially but will be set by the Liquidity providers and traders through the democracy module when the network has enough users.
- Node runner fee - will be set to 0.1% initially but will be set by the node runners through the democracy module when the network has enough community nodes
- Support exchange of KSM & DOT and other parachain assets
- Support other blockchain assets such as ETH, XTZ, BTC when the bridges are ready
- Customizable user interface (user can select any DEX node to connect to, user can adjust allowed slippage, user can select favorite theme etc).
- Optional privacy for users




## Additional Information :heavy_plus_sign: 
Any additional information that you think is relevant to this application that hasn't already been included.

Possible additional information to include:
* What work has been done so far?
* Are there are any teams who have already contributed (financially) to the project?
* Have you applied for other grants so far?



